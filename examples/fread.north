; using syscall 2 (open) and syscall 0 (read) to read a file to mem
; syscall 1 (write) to write it to stdout
; and syscall 3 (close) to close it.
;
; fd, 0 = stdin, 1 = stdout, 2 = stderr
; syscall 2 (open)
; mode flags *filename 2 syscall
; the ´syscall´ token consumes 4 args from the stack and the return (fd for file) is pushed back to the stack

;mode: O_RDONLY 0
;      O_WRONLY 1
;      O_RDWR   2

; flags In addition, zero or more file creation flags and file status
;       flags can be bitwise-or'd in flags

; *filename
; const char *pathname 
; "foo.north" swap drop           ; stack> &str_ptr
; "foo/bar.north" swap drop
; "/foo/bar/baz.north" swap drop

; syscall 0 (read)
; count *buf fd 0 syscall
; the ´syscall´ token consumes 4 args from the stack and the return code (number of bytes read for syscall 0) is pushed back to the stack
; remember read() doesn't add '\0' to terminate to make it string (just gives raw buffer).

; syscall 3 (close)
; fd 3 syscall
; the ´syscall´ token consumes 2 args from the stack and the return (0 for success, -1 for error) is pushed back to the stack

0 0 "/home/cottleb/Documents/north/tests/arithmetic.north" swap drop 2 syscall ;stack> fd 
8 over mem swap 0 syscall drop           

; writing it to stdout
8 mem 1 1 syscall drop

; closing the fd  ;stack> fd 
3 syscall print
